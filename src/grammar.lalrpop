
use crate::tokens::{Token, LexicalError};
use crate::ast;

grammar;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "identifier" => Token::Identifier(<String>),
    "int" => Token::Integer(<i64>),
    "bool" => Token::Boolean(<bool>),
    "if" => Token::If,
    "then" => Token::Then,
    "else" => Token::Else,
    "while" => Token::While,
    "do" => Token::Do,
    "skip" => Token::Skip,
    "{" => Token::LCurlyBracket,
    "}" => Token::RCurlyBracket,
    "(" => Token::LParen,
    ")" => Token::RParen,
    ":=" => Token::Assign,
    ";" => Token::Semicolon,
    "+" => Token::OperatorAdd,
    "-" => Token::OperatorSub,
    "*" => Token::OperatorMul,
    "/" => Token::OperatorDiv,
    "=" => Token::Equal,
    "<" => Token::StrictlyLess,
    "&" => Token::And,
    "!" => Token::Not
  }
}

pub Statement: Box<ast::Statement> = {
  #[precedence(level="1")]
  StatementTerm,
  
  #[precedence(level="2")] #[assoc(side="left")]
  <lhs:Statement> ";" <rhs:Statement> => {
    Box::new(ast::Statement::Composition{ lhs, rhs })
  },
  "if" <guard: BooleanExp> "then" <true_branch: StatementTerm> "else" <false_branch: StatementTerm> => {
    Box::new(ast::Statement::Conditional {
      guard,
      true_branch,
      false_branch
    })
  },
  "while" <guard: BooleanExp> "do" <body: StatementTerm> => {
    Box::new(ast::Statement::While{
      guard,
      body
    })
  }
}

pub StatementTerm: Box<ast::Statement> = {
    <var:"identifier"> ":=" <value:ArithmeticExp> => {
    Box::new(ast::Statement::Assignment(ast::Assignment{var, value}))
  },
  "skip" => Box::new(ast::Statement::Skip),
  "{" <Statement> "}"
}

pub BooleanExp: Box<ast::BooleanExp> = {
  #[precedence(level="1")]
  <guard:"bool"> => Box::new(ast::BooleanExp::Boolean(guard)),

  #[precedence(level="2")] #[assoc(side="right")]
  <exp: BooleanExp> "!" <rhs: BooleanExp> => {
    Box::new(ast::BooleanExp::Not(exp))
  },

#[precedence(level="3")] #[assoc(side="left")]
  <lhs: BooleanExp> "&" <rhs: BooleanExp> => {
    Box::new(ast::BooleanExp::And{
      lhs,
      rhs
    })
  },

#[precedence(level="4")] #[assoc(side="left")]
  <lhs: ArithmeticExp> "=" <rhs: ArithmeticExp> => {
    Box::new(ast::BooleanExp::ArithmeticCondition(ast::ArithmeticCondition{
      lhs,
      operator: ast::ConditionOperator::Equal,
      rhs
    }))
  },
  <lhs: ArithmeticExp> "<" <rhs: ArithmeticExp> => {
    Box::new(ast::BooleanExp::ArithmeticCondition(ast::ArithmeticCondition{
      lhs,
      operator: ast::ConditionOperator::StrictlyLess,
      rhs
    }))
  },
}

pub ArithmeticExp: Box<ast::ArithmeticExp> = {
  #[precedence(level="1")]
  Term,

  #[precedence(level="2")] #[assoc(side="left")]
  <lhs:ArithmeticExp> "*" <rhs:ArithmeticExp> => {
    Box::new(ast::ArithmeticExp::BinaryOperation {
      lhs,
      operator: ast::Operator::Mul,
      rhs
    })
  },
  <lhs:ArithmeticExp> "/" <rhs:ArithmeticExp> => {
    Box::new(ast::ArithmeticExp::BinaryOperation {
      lhs,
      operator: ast::Operator::Div,
      rhs
    })
  },

  #[precedence(level="3")] #[assoc(side="left")]
  <lhs:ArithmeticExp> "+" <rhs:ArithmeticExp> => {
    Box::new(ast::ArithmeticExp::BinaryOperation {
      lhs,
      operator: ast::Operator::Add,
      rhs
    })
  },
  <lhs:ArithmeticExp> "-" <rhs:ArithmeticExp> => {
    Box::new(ast::ArithmeticExp::BinaryOperation {
      lhs,
      operator: ast::Operator::Sub,
      rhs
    })
  },
}

pub Term: Box<ast::ArithmeticExp> = {
  <val:"int"> => {
    Box::new(ast::ArithmeticExp::Integer(val))
  },
  <name:"identifier"> => {
    Box::new(ast::ArithmeticExp::Variable(name))
  },
  "(" <ArithmeticExp> ")",
}
